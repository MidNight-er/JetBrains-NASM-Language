{
    parserClass="com.nasmlanguage.parser.NASMParser"
    parserUtilClass="com.nasmlanguage.parser.NASMParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="NASM"
    psiImplClassSuffix="Impl"
    psiPackage="com.nasmlanguage.psi"
    psiImplPackage="com.nasmlanguage.psi.impl"

    elementTypeHolderClass="com.nasmlanguage.psi.NASMTypes"
    elementTypeClass="com.nasmlanguage.psi.NASMElementType"
    tokenTypeClass="com.nasmlanguage.psi.NASMTokenType"

    psiImplUtilClass="com.nasmlanguage.psi.impl.NASMPsiImplUtil"

    tokens = [
        CRLF                = 'regexp:\R|\n|\r\n'
        //WHITE_SPACE         = 'regexp:[\ \t\f]'
        COMMENT             = 'regexp:;.*'
        EQU                 = 'regexp:[eE][qQ][uU]'
        SECTION_TAG         = 'regexp:[sS][eE][cC][tT][iI][oO][nN]'
        INCLUDE_TAG         = 'regexp:\%[iI][nN][cC][lL][uU][dD][eE]'
        DEFINE_TAG          = 'regexp:\%([xX]?[iI]?[dD][eE][fF][iI][nN][eE])'
        MACRO_TAG           = 'regexp:\%([iI]?[mM][aA][cC][rR][oO])'
        MACRO_END_TAG       = 'regexp:\%([iI]?[eE][nN][dD][mM][aA][cC][rR][oO])'
        CODE_SECTION_NAME   = 'regexp:\.[tT][eE][xX][tT]'
        DATA_SECTION_NAME   = 'regexp:\.[dD][aA][tT][aA]'
        BSS_SECTION_NAME    = 'regexp:\.[bB][sS][sS]'

        DIRECTIVE_OP        = 'regexp:[bB][iI][tT][sS]|[uU][sS][eE]16|[uU][sS][eE]32|[sS][eE][cC][tT][iI][oO][nN]|[sS][eE][gG][mM][eE][nN][tT]|[aA][bB][sS][oO][lL][uU][tT][eE]|[eE][xX][tT][eE][rR][nN]|[gG][lL][oO][bB][aA][lL]|[oO][rR][gG]|[aA][lL][iI][gG][nN]|[sS][tT][rR][uU][cC]|[eE][nN][dD][sS][tT][rR][uU][cC]|[cC][oO][mM][mM][oO][nN]|[cC][pP][uU]|[gG][rR][oO][uU][pP]|[uU][pP][pP][eE][rR][cC][aA][sS][eE]|[iI][mM][pP][oO][rR][tT]|[eE][xX][pP][oO][rR][tT]|[lL][iI][bB][rR][aA][rR][yY]|[mM][oO][dD][uU][lL][eE]'
        PREPROCESSOR_OP     = 'regexp:\%([xX]?[iI]?[dD][eE][fF][iI][nN][eE]|[uU][nN][dD][eE][fF]|[aA][sS][sS][iI][gG][nN]|[iI]?[dD][eE][fF][sS][tT][rR]|[iI]?[dD][eE][fF][tT][oO][kK]|[sS][tT][rR][cC][aA][tT]|[sS][tT][rR][lL][eE][nN]|[sS][uU][bB][sS][tT][rR]|[iI]?[mM][aA][cC][rR][oO]|[eE][nN][dD][mM][aA][cC][rR][oO]|[rR][oO][tT][aA][tT][eE]|[rR][eE][pP]|[eE][nN][dD][rR][eE][pP])'
        DATA_OP             = 'regexp:(res|d)[bwdqt]|[tT][iI][mM][eE][sS]'

        // General purpose instructions
        INS_DATA_TRANS_MOV  = 'regexp:(mov([sz]x)?|cmov(n?[abceglopsz]|n?[abgl]e|p[eo]))|(xchg|bswap|xadd|cmpxchg(8b)?)'                                // Data Transfer MOV
        INS_DATA_TRANS_XCHG = 'regexp:(xchg|bswap|xadd|cmpxchg(8b)?)'                                                                                   // Data Transfer XCHG
        INS_DATA_TRANS_OTHER= 'regexp:((push|pop)(ad?)?|cwde?|cdq|cbw)'                                                                                 // Data Transfer Other
        INS_DECIMAL_ARITH   = 'regexp:(daa|das|aaa|aas|aam|aad)'                                                                                        // Decimal Arithmetic
        INS_BINARY_ARITH    = 'regexp:(adcx?|adox|add|sub|sbb|i?mul|i?div|inc|dec|neg|cmp)'                                                             // Binary Arithmetic
        INS_BINARY_LOGICAL  = 'regexp:(and|x?or|not)'                                                                                                   // Binary Logical
        INS_BINARY_ROTATE   = 'regexp:(s[ah][rl]|sh[rl]d|r[co][rl])'                                                                                    // Binary Rotation
        INS_BINARY_SET      = 'regexp:(set(n?[abceglopsz]|n?[abgl]e|p[eo]))'                                                                            // Binary Set
        INS_BINARY_OTHER    = 'regexp:(bt[crs]?|bs[fr]|test|crc32|popcnt)'                                                                              // Binary Other
        INS_CONTROL_TRANS   = 'regexp:(jmp|jn?[abceglopsz]|jn?[abgl]e|jp[eo]|j[er]?cxz)|(loop(n?[ez])?|call|ret|iret[dq]?|into?|bound|enter|leave)'     // Control Transfer
        INS_STRING_DATA     = 'regexp:((mov|cmp|sca|lod|sto)(s[bdw]?)|rep(n?[ez])?)'                                                                    // String Data
        INS_INPUT_OUTPUT    = 'regexp:((in|out)(s[bdw]?)?)'                                                                                             // I/O
        INS_FLAG_CONTROL    = 'regexp:((st|cl)[cdi]|cmc|[ls]ahf|(push|pop)f[dq]?)'                                                                      // Flag Control
        INS_SEG_REGS        = 'regexp:(l[defgs]s)'                                                                                                      // Segment Registers
        INS_MISC_OTHER      = 'regexp:(lea|nop|ud2|xlatb?|cpuid|movbe)'                                                                                 // Misc/Other
        INS_RNG_RAND        = 'regexp:(rdrand|rdseed)'                                                                                                  // Random Number Generation (RNG)
        INS_BIT_MANIPULATION= 'regexp:(andn|bextr|bls(i|r|msk)|bzhi|pdep|pext|[lt]zcnt|(mul|ror|sar|shl|shr)x)'                                         // Bit Manipulation (BMI)

        // 64 bit instructions
        INS_64_BIT          = 'regexp:(cdqe|cqo|(cmp|lod|mov|sto)sq|cmpxchg16b|mov(ntq|sxd)|scasq|swapgs|sys(call|ret))'                                // 64 bit Instructions

        // FPU instructions
        INS_FPU_DATA_TRANS  = 'regexp:(fcmov(n?([beu]|be)))|(f(i?(ld|stp?)|b(ld|stp)|xch))'                                                             // FPU Data Transfer
        INS_FPU_BASIC_ARITH = 'regexp:(f((add|div|mul|sub)p?|i(add|div|mul|sub)|(div|sub)rp?|i(div|sub)r))|(f(prem1?|abs|chs|rndint|scale|sqrt|xtract))'// FPU Basic Arithmetic
        INS_FPU_COMPARISON  = 'regexp:(f(u?com[ip]?p?|icomp?|tst|xam))'                                                                                 // FPU Comparison
        INS_FPU_TRANSCEND   = 'regexp:(f(sin|cos|sincos|pa?tan|2xm1|yl2x(p1)?))'                                                                        // FPU Transcendental
        INS_FPU_LOAD        = 'regexp:(fld(1|z|pi|l2[et]|l[ng]2))'                                                                                      // FPU Load
        INS_FPU_CONTROL     = 'regexp:(f((inc|dec)stp|free|n?(init|clex|st[cs]w|stenv|save)|ld(cw|env)|rstor|nop)|f?wait)'                              // FPU Control Management
        INS_FPU_STATE       = 'regexp:(fx(save|rstor)(64)?)'                                                                                            // FPU State Management

        // MMX instructions
        INS_MMX_DATA_TRANS  = 'regexp:(mov[dq])'
        INS_MMX_CONVERSION  = 'regexp:(pack(ssdw|[su]swb)|punpck[hl](bw|dq|wd))'
        INS_MMX_ARITH       = 'regexp:(p(((add|sub)(d|(u?s)?[bw]))|maddwd|mul[lh]w))'
        INS_MMX_COMPARISON  = 'regexp:(pcmp((eq|gt)[bdw]))'
        INS_MMX_LOGICAL     = 'regexp:(pandn?|px?or)'
        INS_MMX_ROTATE      = 'regexp:(ps([rl]l[dwq]|raw|rad))'
        INS_MMX_STATE       = 'regexp:(emms)'

        // SSE instructions
        INS_SSE_DATA_TRANS  = 'regexp:(mov(([ahlu]|hl|lh|msk)ps|ss))'
        INS_SSE_ARITH       = 'regexp:((add|div|max|min|mul|rcp|r?sqrt|sub)[ps]s)'
        INS_SSE_COMPARISON  = 'regexp:(cmp[ps]s|u?comiss)'
        INS_SSE_LOGICAL     = 'regexp:((andn?|x?or)ps)'
        INS_SSE_OTHER       = 'regexp:((shuf|unpck[hl])ps)'
        INS_SSE_CONVERSION  = 'regexp:(cvt(pi2ps|si2ss|ps2pi|tps2pi|ss2si|tss2si))'
        INS_SSE_STATE       = 'regexp:((ld|st)mxcsr)'
        INS_SSE_SIMD_INT    = 'regexp:(p(avg[bw]|extrw|insrw|(max|min)(sw|ub)|sadbw|shufw|mulhuw|movmskb))'
        INS_SSE_CACHE_CTRL  = 'regexp:(maskmovq|movntps|sfence)'
        INS_SSE_PREFETCH    = 'regexp:(prefetch(nta|t[0-2]|w(t1)?))'



        OP_PREFIX           = 'regexp:((rep(n?[ez])|rep)|lock|[c-gs]s)' // Instruction operation prefixes
        GENERAL_OP          = 'regexp:{INS_DATA_TRANS_MOV}|{INS_DATA_TRANS_XCHG}|{INS_DATA_TRANS_OTHER}|{INS_DECIMAL_ARITH}|{INS_BINARY_ARITH}|{INS_BINARY_LOGICAL}|{INS_BINARY_ROTATE}|{INS_BINARY_SET}|{INS_BINARY_OTHER}|{INS_CONTROL_TRANS}|{INS_STRING_DATA}|{INS_INPUT_OUTPUT}|{INS_FLAG_CONTROL}|{INS_SEG_REGS}|{INS_MISC_OTHER}|{INS_RNG_RAND}|{INS_BIT_MANIPULATION}'
        X64_OP              = 'regexp:{INS_64_BIT}'
        FPU_OP              = 'regexp:{INS_FPU_DATA_TRANS}|{INS_FPU_BASIC_ARITH}|{INS_FPU_COMPARISON}|{INS_FPU_TRANSCEND}|{INS_FPU_LOAD}|{INS_FPU_CONTROL}|{INS_FPU_STATE}'
        MMX_OP              = 'regexp:{INS_MMX_DATA_TRANS}|{INS_MMX_CONVERSION}|{INS_MMX_ARITH}|{INS_MMX_COMPARISON}|{INS_MMX_LOGICAL}|{INS_MMX_ROTATE}|{INS_MMX_STATE}'
        SSE_OP              = 'regexp:{INS_SSE_DATA_TRANS}|{INS_SSE_ARITH}|{INS_SSE_COMPARISON}|{INS_SSE_LOGICAL}|{INS_SSE_OTHER}|{INS_SSE_CONVERSION}|{INS_SSE_STATE}|{INS_SSE_SIMD_INT}|{INS_SSE_CACHE_CTRL}|{INS_SSE_PREFETCH}'

        REGISTER            = 'regexp:[a-d][lh]|([er])?[a-d]x|([er])?[sb]p|([er])?[sd]i|[c-gs]s|st[0-7]|x?mm[0-7]|cr[0-4]|dr[0-367]|tr[3-7]'
        SIZE_TYPE           = 'regexp:byte|short|[dq]?word'
        NUMBER              = 'regexp:0b[0-1]+|0y[0-1]+|[0-1][0-1]*b|[0-1][0-1]*y|0[xX][0-9a-fA-F]+|0[hH][0-9a-fA-F]+|\$[0-9]+[0-9a-fA-F]*|[0-9]+[0-9a-fA-F]*h|(([1-9][0-9]*\.?[0-9]*)|(\.[0-9]+))([Ee][+-]?[0-9]+)?|0d[0-9]+|[0-9]+'
        STRING              = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
        LABEL_DEF           = 'regexp:[a-zA-Z$._?][a-zA-Z0-9$._?#@\126]*:'

        // Make last!
        IDENTIFIER          = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        LABEL               = 'regexp:[a-zA-Z$._?][a-zA-Z0-9$._?#@\126]*' // Label can have chars like '.', '?', '@', etc

        COLON               = ':'
        SQUARE_L            = '['
        SQUARE_R            = ']'
        ROUND_L             = '('
        ROUND_R             = ')'
        SEPARATOR           = ','
        DOT                 = '.'

        PLUS                = '+'
        MINUS               = '-'
        TIMES               = '*'
        DIVIDE              = '\'

        DOLLARSIGN          = '$'
        DOLLARSIGN2         = '$$'
        PERCENT             = '%'

    ]

}

NASMFile ::= Element*

private Element ::= COMMENT
                | CRLF
                | COMMENT CRLF
                | Section
                | Preprocessor
                | Directive
                | SQUARE_L Section SQUARE_R
                | SQUARE_L Directive SQUARE_R
                | Data
                | Instruction
                ;

private Section ::= DataSection | CodeSection
DataSection ::= (SECTION_TAG DATA_SECTION_NAME CRLF* (Data | Directive)*)
CodeSection ::= (SECTION_TAG CODE_SECTION_NAME CRLF* (Instruction | Directive)*)

Preprocessor ::= (Include | Define | Macro | PREPROCESSOR_OP)
Include ::= (INCLUDE_TAG STRING) {methods=[getIncludeString]}
Define ::= (DEFINE_TAG IDENTIFIER (NumericLiteral|((PERCENT SQUARE_L)? IDENTIFIER SQUARE_R?)))
        | (DEFINE_TAG (IDENTIFIER ROUND_L ((IDENTIFIER SEPARATOR)* IDENTIFIER)? ROUND_R) Expression) {methods=[getDefineIdentifier]}
Macro ::= (MACRO_TAG IDENTIFIER MacroParams MacroDefaultParam? CRLF* (Data | Instruction)* MACRO_END_TAG) {methods=[getMacroIdentifier]}

Directive ::= (DIRECTIVE_OP (DirectiveArg)*)
DirectiveArg ::= NumericLiteral | Address | Identifier

Data ::= ((LABEL_DEF? DATA_OP DataValue?) | (Identifier EQU NumericExpression))
DataValue ::= ((NumericLiteral|STRING) SEPARATOR?)*

Instruction ::= (LABEL_DEF? ((MnemonicOperation ((MnemonicOperationArg SEPARATOR)* MnemonicOperationArg)? COMMENT?) | Directive | MacroCall))
private MnemonicOperation ::= (OP_PREFIX? (GENERAL_OP | X64_OP | FPU_OP | MMX_OP | SSE_OP))
private MnemonicOperationArg ::= REGISTER | NumericLiteral | Address | MacroCall | Identifier

Address ::= SIZE_TYPE? SQUARE_L AddressInternal SQUARE_R
private AddressInternal ::= ((REGISTER|MacroCall|Identifier) ((PLUS|MINUS|TIMES) (((NumericLiteral|MacroCall|Identifier) (PLUS|MINUS|TIMES))*)? (NumericLiteral|REGISTER|MacroCall|Identifier))? ((PLUS|MINUS|TIMES) (NumericLiteral|MacroCall|Identifier))?)

MacroCall ::= (IDENTIFIER ROUND_L ((NumericExpression SEPARATOR)* NumericExpression)? ROUND_R)
private MacroParams ::= ((NumericLiteral MINUS ((NumericLiteral TIMES)|NumericLiteral|TIMES)) | NumericLiteral PLUS)
private MacroDefaultParam ::= (Instruction|STRING|REGISTER|NumericLiteral)

private NumericExpression ::= (((NumericLiteral|MacroCall|IDENTIFIER)(PLUS|MINUS|TIMES))* (NumericLiteral|MacroCall|IDENTIFIER))
private Expression ::= (((NumericLiteral|REGISTER|MacroCall|IDENTIFIER)(PLUS|MINUS|TIMES))* (NumericLiteral|REGISTER|MacroCall|IDENTIFIER))

private Identifier ::= (SIZE_TYPE? (LABEL|IDENTIFIER))
private NumericLiteral ::= ((PLUS|MINUS)? NUMBER)