{
    parserClass="com.nasmlanguage.parser.NASMParser"
    parserUtilClass="com.nasmlanguage.parser.NASMParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="NASM"
    psiImplClassSuffix="Impl"
    psiPackage="com.nasmlanguage.psi"
    psiImplPackage="com.nasmlanguage.psi.impl"

    elementTypeHolderClass="com.nasmlanguage.psi.NASMTypes"
    elementTypeClass="com.nasmlanguage.psi.NASMElementType"
    tokenTypeClass="com.nasmlanguage.psi.NASMTokenType"

    psiImplUtilClass="com.nasmlanguage.psi.impl.NASMPsiImplUtil"

    tokens = [
        CRLF                = 'regexp:\r|\n|\r\n'
        WHITE_SPACE         = 'regexp:[ \t\x0B\f]+'

        COMMENT             = 'regexp:(;.*?(\r|\n|\r\n)?)'
        EQU                 = 'regexp:([eE][qQ][uU])'

        STRUC_TAG           = 'regexp:([sS][tT][rR][uU][cC])'
        ENDSTRUC_TAG        = 'regexp:([eE][nN][dD][sS][tT][rR][uU][cC])'
        ISTRUC_TAG          = 'regexp:([iI][sS][tT][rR][uU][cC])'
        IEND_TAG            = 'regexp:([iI][eE][nN][dD])'
        AT_TAG              = 'regexp:([aA][tT])'


        INCLUDE_TAG         = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI][nN][cC][lL][uU][dD][eE])'
        DEFINE_TAG          = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([xX]?[iI]?[dD][eE][fF][iI][nN][eE])'
        MACRO_TAG           = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI]?[mM][aA][cC][rR][oO])'
        MACRO_END_TAG       = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI]?[eE][nN][dD][mM][aA][cC][rR][oO])'
        IF_TAG              = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI][fF][nN]?([dD][eE][fF])?)'
        IFMACRO_TAG         = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI][fF][mM][aA][cC][rR][oO])'
        IFCTX_TAG           = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI][fF][cC][tT][xX])'
        ELIF_TAG            = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([eE][lL][iI][fF][nN]?([dD][eE][fF])?)'
        ELSE_TAG            = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([eE][lL][sS][eE])'
        ENDIF_TAG           = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([eE][nN][dD][iI][fF])'
        ERROR_TAG           = 'regexp:((({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([eE][rR][rR][oO][rR])).*'

        SECTION_TAG         = 'regexp:([sS][eE][cC][tT][iI][oO][nN])'
        CODE_SECTION_NAME   = 'regexp:(\.[tT][eE][xX][tT])'
        DATA_SECTION_NAME   = 'regexp:(\.[dD][aA][tT][aA])'
        BSS_SECTION_NAME    = 'regexp:(\.[bB][sS][sS])'


        DIRECTIVE_OP        = 'regexp:[bB][iI][tT][sS]|[uU][sS][eE]16|[uU][sS][eE]32|[sS][eE][cC][tT][iI][oO][nN]|[sS][eE][gG][mM][eE][nN][tT]|[aA][bB][sS][oO][lL][uU][tT][eE]|[eE][xX][tT][eE][rR][nN]|[gG][lL][oO][bB][aA][lL]|[oO][rR][gG]|[aA][lL][iI][gG][nN]|[sS][tT][rR][uU][cC]|[eE][nN][dD][sS][tT][rR][uU][cC]|[cC][oO][mM][mM][oO][nN]|[cC][pP][uU]|[gG][rR][oO][uU][pP]|[uU][pP][pP][eE][rR][cC][aA][sS][eE]|[iI][mM][pP][oO][rR][tT]|[eE][xX][pP][oO][rR][tT]|[lL][iI][bB][rR][aA][rR][yY]|[mM][oO][dD][uU][lL][eE]'
        PREPROCESSOR_OP     = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([xX]?[iI]?[dD][eE][fF][iI][nN][eE]|[uU][nN][dD][eE][fF]|[aA][sS][sS][iI][gG][nN]|[iI]?[dD][eE][fF][sS][tT][rR]|[iI]?[dD][eE][fF][tT][oO][kK]|[sS][tT][rR][cC][aA][tT]|[sS][tT][rR][lL][eE][nN]|[sS][uU][bB][sS][tT][rR]|[iI]?[mM][aA][cC][rR][oO]|[eE][nN][dD][mM][aA][cC][rR][oO]|[rR][oO][tT][aA][tT][eE]|[rR][eE][pP]|[eE][nN][dD][rR][eE][pP])'
        DATA_OP             = 'regexp:(([rR][eE][sS])|[dD])[bBwWdDqQtT]|[tT][iI][mM][eE][sS]'

        // General purpose instructions
        INS_DATA_TRANS_MOV  = 'regexp:(mov([sz]x)?|cmov(n?[abceglopsz]|n?[abgl]e|p[eo]))|(xchg|bswap|xadd|cmpxchg(8b)?)'                                // Data Transfer MOV
        INS_DATA_TRANS_XCHG = 'regexp:(xchg|bswap|xadd|cmpxchg(8b)?)'                                                                                   // Data Transfer XCHG
        INS_DATA_TRANS_OTHER= 'regexp:((push|pop)(ad?)?|cwde?|cdq|cbw)'                                                                                 // Data Transfer Other
        INS_DECIMAL_ARITH   = 'regexp:(daa|das|aaa|aas|aam|aad)'                                                                                        // Decimal Arithmetic
        INS_BINARY_ARITH    = 'regexp:(adcx?|adox|add|sub|sbb|i?mul|i?div|inc|dec|neg|cmp)'                                                             // Binary Arithmetic
        INS_BINARY_LOGICAL  = 'regexp:(and|x?or|not)'                                                                                                   // Binary Logical
        INS_BINARY_ROTATE   = 'regexp:(s[ah][rl]|sh[rl]d|r[co][rl])'                                                                                    // Binary Rotation
        INS_BINARY_SET      = 'regexp:(set(n?[abceglopsz]|n?[abgl]e|p[eo]))'                                                                            // Binary Set
        INS_BINARY_OTHER    = 'regexp:(bt[crs]?|bs[fr]|test|crc32|popcnt)'                                                                              // Binary Other
        INS_CONTROL_TRANS   = 'regexp:(jmp|jn?[abceglopsz]|jn?[abgl]e|jp[eo]|j[er]?cxz)|(loop(n?[ez])?|call|ret|retn|iret[dq]?|into?|bound|enter|leave)'     // Control Transfer
        INS_STRING_DATA     = 'regexp:((mov|cmp|sca|lod|sto)(s[bdw]?)|rep(n?[ez])?)'                                                                    // String Data
        INS_INPUT_OUTPUT    = 'regexp:((in|out)(s[bdw]?)?)'                                                                                             // I/O
        INS_FLAG_CONTROL    = 'regexp:((st|cl)[cdi]|cmc|[ls]ahf|(push|pop)f[dq]?)'                                                                      // Flag Control
        INS_SEG_REGS        = 'regexp:(l[defgs]s)'                                                                                                      // Segment Registers
        INS_MISC_OTHER      = 'regexp:(lea|nop|ud2|xlatb?|cpuid|movbe)'                                                                                 // Misc/Other
        INS_RNG_RAND        = 'regexp:(rdrand|rdseed)'                                                                                                  // Random Number Generation (RNG)
        INS_BIT_MANIPULATION= 'regexp:(andn|bextr|bls(i|r|msk)|bzhi|pdep|pext|[lt]zcnt|(mul|ror|sar|shl|shr)x)'                                         // Bit Manipulation (BMI)

        // 64 bit instructions
        INS_64_BIT          = 'regexp:(cdqe|cqo|(cmp|lod|mov|sto)sq|cmpxchg16b|mov(ntq|sxd)|scasq|swapgs|sys(call|ret))'                                // 64 bit Instructions

        // FPU instructions
        INS_FPU_DATA_TRANS  = 'regexp:(fcmov(n?([beu]|be)))|(f(i?(ld|stp?)|b(ld|stp)|xch))'                                                             // FPU Data Transfer
        INS_FPU_BASIC_ARITH = 'regexp:(f((add|div|mul|sub)p?|i(add|div|mul|sub)|(div|sub)rp?|i(div|sub)r))|(f(prem1?|abs|chs|rndint|scale|sqrt|xtract))'// FPU Basic Arithmetic
        INS_FPU_COMPARISON  = 'regexp:(f(u?com[ip]?p?|icomp?|tst|xam))'                                                                                 // FPU Comparison
        INS_FPU_TRANSCEND   = 'regexp:(f(sin|cos|sincos|pa?tan|2xm1|yl2x(p1)?))'                                                                        // FPU Transcendental
        INS_FPU_LOAD        = 'regexp:(fld(1|z|pi|l2[et]|l[ng]2))'                                                                                      // FPU Load
        INS_FPU_CONTROL     = 'regexp:(f((inc|dec)stp|free|n?(init|clex|st[cs]w|stenv|save)|ld(cw|env)|rstor|nop)|f?wait)'                              // FPU Control Management
        INS_FPU_STATE       = 'regexp:(fx(save|rstor)(64)?)'                                                                                            // FPU State Management

        // MMX instructions
        INS_MMX_DATA_TRANS  = 'regexp:(mov[dq])'
        INS_MMX_CONVERSION  = 'regexp:(pack(ssdw|[su]swb)|punpck[hl](bw|dq|wd))'
        INS_MMX_ARITH       = 'regexp:(p(((add|sub)(d|(u?s)?[bw]))|maddwd|mul[lh]w))'
        INS_MMX_COMPARISON  = 'regexp:(pcmp((eq|gt)[bdw]))'
        INS_MMX_LOGICAL     = 'regexp:(pandn?|px?or)'
        INS_MMX_ROTATE      = 'regexp:(ps([rl]l[dwq]|raw|rad))'
        INS_MMX_STATE       = 'regexp:(emms)'

        // SSE instructions
        INS_SSE_DATA_TRANS  = 'regexp:(mov(([ahlu]|hl|lh|msk)ps|ss))'
        INS_SSE_ARITH       = 'regexp:((add|div|max|min|mul|rcp|r?sqrt|sub)[ps]s)'
        INS_SSE_COMPARISON  = 'regexp:(cmp[ps]s|u?comiss)'
        INS_SSE_LOGICAL     = 'regexp:((andn?|x?or)ps)'
        INS_SSE_OTHER       = 'regexp:((shuf|unpck[hl])ps)'
        INS_SSE_CONVERSION  = 'regexp:(cvt(pi2ps|si2ss|ps2pi|tps2pi|ss2si|tss2si))'
        INS_SSE_STATE       = 'regexp:((ld|st)mxcsr)'
        INS_SSE_SIMD_INT    = 'regexp:(p(avg[bw]|extrw|insrw|(max|min)(sw|ub)|sadbw|shufw|mulhuw|movmskb))'
        INS_SSE_CACHE_CTRL  = 'regexp:(maskmovq|movntps|sfence)'
        INS_SSE_PREFETCH    = 'regexp:(prefetch(nta|t[0-2]|w(t1)?))'

        // SSE2 instructions
        INS_SSE2_DATA_TRANS = 'regexp:(mov([auhl]|msk)pd)'
        INS_SSE2_ARITH      = 'regexp:((add|div|max|min|mul|sub|sqrt)[ps]d)'
        INS_SSE2_LOGICAL    = 'regexp:((andn?|x?or)pd)'
        INS_SSE2_COMPARISON = 'regexp:((cmpp|u?comis)d)'
        INS_SSE2_OTHER      = 'regexp:((shuf|unpck[hl])pd)'
        INS_SSE2_CONVERSION = 'regexp:(cvt(dq2pd|pi2pd|ps2pd|pd2ps|si2sd|sd2ss|ss2sd|t?(pd2dq|pd2pi|sd2si)))|(cvt(dq2ps|ps2dq|tps2dq))'
        INS_SSE2_SIMD_INT   = 'regexp:(mov(dq[au]|q2dq|dq2q))|(p((add|sub|(s[lr]l|mulu|unpck[hl]q)d)q|shuf(d|[hl]w)))'
        INS_SSE2_CACHE_CTRL = 'regexp:(clflush|[lm]fence|pause|maskmovdqu|movnt(dq|i|pd))'

        // SSE3 instructions
        INS_SSE3_GENERAL    = 'regexp:(fisttp|lddqu|(addsub|h(add|sub))p[sd]|mov(sh|sl|d)dup|monitor|mwait)'
        INS_SSE3_ARITH      = 'regexp:(ph(add|sub)(s?w|d))'
        INS_SSE3_OTHER      = 'regexp:(p((abs|sign)[bdw]|maddubsw|mulhrsw|shufb|alignr))'

        // SSE4 instructions
        INS_SSE4_ARITH      = 'regexp:(pmul(ld|dq)|dpp[ds])'
        INS_SSE4_DATA_TRANS = 'regexp:(movntdqa)'
        INS_SSE4_BLEND      = 'regexp:(blendv?p[ds]|pblend(vb|w))'
        INS_SSE4_PACKED_INT = 'regexp:(p(min|max)(u[dw]|s[bd]))'
        INS_SSE4_PACKED_FP  = 'regexp:(round[ps][sd])'
        INS_SSE4_INS_EXT    = 'regexp:((extract|insert)ps|p((ins|ext)(r[bdq])))'
        INS_SSE4_CONVERSION = 'regexp:(pmov([sz]x(b[dqw]|dq|wd|wq)))'
        INS_SSE4_OTHER      = 'regexp:(mpsadbw|phminposuw|ptest|pcmpeqq|packusdw)|(pcmp([ei]str[im]|gtq))'

        // Instruction operation prefixes
        OP_PREFIX           = 'regexp:((rep(n?[ez])|rep)|lock|[c-gs]s)'

        // Instructions
        GENERAL_OP          = 'regexp:{INS_DATA_TRANS_MOV}|{INS_DATA_TRANS_XCHG}|{INS_DATA_TRANS_OTHER}|{INS_DECIMAL_ARITH}|{INS_BINARY_ARITH}|{INS_BINARY_LOGICAL}|{INS_BINARY_ROTATE}|{INS_BINARY_SET}|{INS_BINARY_OTHER}|{INS_CONTROL_TRANS}|{INS_STRING_DATA}|{INS_INPUT_OUTPUT}|{INS_FLAG_CONTROL}|{INS_SEG_REGS}|{INS_MISC_OTHER}|{INS_RNG_RAND}|{INS_BIT_MANIPULATION}'
        X64_OP              = 'regexp:{INS_64_BIT}'
        FPU_OP              = 'regexp:{INS_FPU_DATA_TRANS}|{INS_FPU_BASIC_ARITH}|{INS_FPU_COMPARISON}|{INS_FPU_TRANSCEND}|{INS_FPU_LOAD}|{INS_FPU_CONTROL}|{INS_FPU_STATE}'
        MMX_OP              = 'regexp:{INS_MMX_DATA_TRANS}|{INS_MMX_CONVERSION}|{INS_MMX_ARITH}|{INS_MMX_COMPARISON}|{INS_MMX_LOGICAL}|{INS_MMX_ROTATE}|{INS_MMX_STATE}'
        SSE_OP              = 'regexp:{INS_SSE_DATA_TRANS}|{INS_SSE_ARITH}|{INS_SSE_COMPARISON}|{INS_SSE_LOGICAL}|{INS_SSE_OTHER}|{INS_SSE_CONVERSION}|{INS_SSE_STATE}|{INS_SSE_SIMD_INT}|{INS_SSE_CACHE_CTRL}|{INS_SSE_PREFETCH}'
        SSE2_OP             = 'regexp:{INS_SSE2_DATA_TRANS}|{INS_SSE2_ARITH}|{INS_SSE2_LOGICAL}|{INS_SSE2_COMPARISON}|{INS_SSE2_OTHER}|{INS_SSE2_CONVERSION}|{INS_SSE2_SIMD_INT}|{INS_SSE2_CACHE_CTRL}'
        SSE3_OP             = 'regexp:{INS_SSE3_GENERAL}|{INS_SSE3_ARITH}|{INS_SSE3_OTHER}'
        SSE4_OP             = 'regexp:{INS_SSE4_ARITH}|{INS_SSE4_DATA_TRANS}|{INS_SSE4_BLEND}|{INS_SSE4_PACKED_INT}|{INS_SSE4_PACKED_FP}|{INS_SSE4_INS_EXT}|{INS_SSE4_CONVERSION}|{INS_SSE4_OTHER}'

        // All kinds of registers
        REGISTER            = 'regexp:%?(([abcd][hl])|([er]?[abcd]x)|([er]?[sb]p)|([er]?[sd]i|dil|sil|bpl|spl)|([er]?ip)|(r(8|9|1[0-5])[bdlw]?)|([cdefgs]s)|([er]?flags)|(cr[02348])|(dr[012367])|(tr[34567])|(([gil]dt)r?|tr)|(bnd([0-3]|cfg[su]|status))|((mm|st|fpr)[0-7])|([xy]mm([0-9]|1[0-5])|mxcsr))'
        SIZE_TYPE           = 'regexp:[bB][yY][tT][eE]|[sS][hH][oO][rR][tT]|[lL][oO][nN][gG]|([dDqQoO]|[xX][mM][mM])?[wW][oO][rR][dD]'
        BINARY              = 'regexp:(0[bB][0-1]+|0[yY][0-1]+|[0-1][0-1]*[bB]|[0-1][0-1]*[yY])'
        HEXADECIMAL         = 'regexp:(0[xX][0-9a-fA-F]+|0[hH][0-9a-fA-F]+|\$[0-9]+[0-9a-fA-F]*|[0-9]+[0-9a-fA-F]*[hH])'
        DECIMAL             = 'regexp:((([1-9][0-9]*\.?[0-9]*)|(\.[0-9]+))([Ee][+-]?[0-9]+)?|0[dD][0-9]+|[0-9]+)'
        CHARACTER           = "regexp:('([^'\\]|\\.)')"
        STRING              = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
        LBL_DEF             = 'regexp:[a-zA-Z$._?][a-zA-Z0-9$._?#@\126]*:'

        // Make last!
        IDENTIFIER          = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        LBL                 = 'regexp:[a-zA-Z$._?][a-zA-Z0-9$._?#@\126]*' // Lbl can have chars like '.', '?', '@', etc

        COLON               = ':'
        SEMICOLON           = ';'
        SQUARE_L            = '['
        SQUARE_R            = ']'
        ROUND_L             = '('
        ROUND_R             = ')'
        SEPARATOR           = ','
        DOT                 = '.'

        EQUAL               = '='
        EQUALEQUAL          = '=='
        PLUS                = '+'
        MINUS               = '-'
        TIMES               = '*'
        DIVIDE              = '/'

        DOLLARSIGN          = '$'
        DOLLARSIGN2         = '$$'
        PERCENT             = '%'
    ]

}

NASMFile ::= Element*

private Element ::= COMMENT
                | CRLF
                | COMMENT CRLF
                | Label
                | Data
                | Instruction
                | Preprocessor
                | Section
                | Directive
                | SQUARE_L Section SQUARE_R
                | SQUARE_L Directive SQUARE_R
                ;

private Section ::= DataSection | CodeSection
DataSection ::= (SECTION_TAG DATA_SECTION_NAME CRLF* (Data|Directive)*)
CodeSection ::= (SECTION_TAG CODE_SECTION_NAME CRLF* (Instruction|Directive)*)

Preprocessor ::= (Include|Define|Macro|Conditional|Error|PREPROCESSOR_OP)
Include ::= (INCLUDE_TAG STRING) {methods=[getIncludeString]}
Define ::= (DEFINE_TAG IDENTIFIER (NumericLiteral|Address|((PERCENT SQUARE_L)? IDENTIFIER SQUARE_R?)) CRLF*)
        | (DEFINE_TAG (IDENTIFIER ROUND_L ((IDENTIFIER SEPARATOR)* IDENTIFIER)? ROUND_R) Expression CRLF*) {methods=[getDefineIdentifier]}
Macro ::= (MACRO_TAG IDENTIFIER MacroParams MacroDefaultParam? CRLF* (Data|Instruction)* MACRO_END_TAG) {methods=[getMacroIdentifier]}
Conditional ::= (IF_TAG Condition CRLF* (Preprocessor|Directive|Data|Instruction)* ((ELIF_TAG Condition|ELSE_TAG) CRLF* (Preprocessor|Directive|Data|Instruction)*)*  ENDIF_TAG)
                | (IFMACRO_TAG IDENTIFIER MacroParams MacroDefaultParam? CRLF* (Preprocessor|Directive|Data|Instruction)* ENDIF_TAG)
Error ::= ERROR_TAG CRLF*

Label ::= (LBL_DEF (Instruction|Data|CRLF*)) {methods=[getLabelIdentifier]}

Data ::= (IDENTIFIER EQU (NumericExpression|(DOLLARSIGN MINUS Identifier)))
        | (LBL_DEF? DATA_OP DataValue?)
        | (LBL_DEF? (IStruc|Struc) CRLF*)
        ;
DataValue ::= ((NumericLiteral|STRING|IDENTIFIER|LBL) SEPARATOR?)*
Struc ::= (STRUC_TAG IDENTIFIER CRLF* ((LBL|LBL_DEF) DATA_OP? DataValue? CRLF*)* ENDSTRUC_TAG)
IStruc ::= (ISTRUC_TAG IDENTIFIER CRLF* (AT_TAG LBL SEPARATOR DATA_OP DataValue? CRLF*)* IEND_TAG)

Instruction ::= (((MnemonicOperation ((MnemonicOperationArg SEPARATOR)* MnemonicOperationArg)? COMMENT? CRLF*) | Directive | MacroCall | LBL_DEF) CRLF*)
private MnemonicOperation ::= (OP_PREFIX? (GENERAL_OP|X64_OP|FPU_OP|MMX_OP|SSE_OP|SSE2_OP|SSE3_OP|SSE4_OP))
private MnemonicOperationArg ::= (ROUND_L Expression ROUND_R)|Expression|REGISTER|NumericLiteral|Address|MacroCall|Identifier|

Directive ::= (DIRECTIVE_OP DirectiveArg* CRLF*)
DirectiveArg ::= (NumericLiteral|Address|Identifier)


MacroCall ::= (IDENTIFIER ROUND_L ((NumericExpression SEPARATOR)* NumericExpression)? ROUND_R CRLF*)
private MacroParams ::= (NumericLiteral MINUS NumericLiteral TIMES?)
                        | (NumericLiteral MINUS TIMES)
                        | (NumericLiteral PLUS)
                        ;
private MacroDefaultParam ::= (Instruction|STRING|REGISTER|NumericLiteral|MacroCall)

private NumericExpression ::= (((NumericLiteral|MacroCall|Identifier) ArithmeticOperation)* (NumericLiteral|MacroCall|Identifier))
private Expression ::= (((NumericLiteral|REGISTER|Address|MacroCall|Identifier) ArithmeticOperation)* (NumericLiteral|REGISTER|Address|MacroCall|Identifier))

private Condition ::= ((Expression EQUALEQUAL Expression)|Expression)

Address ::= (SIZE_TYPE? SQUARE_L AddressInternal SQUARE_R)
private AddressInternal ::= ((REGISTER|MacroCall|NumericLiteral|Identifier)(ArithmeticOperation (REGISTER|MacroCall|NumericLiteral|Identifier))*)

private Identifier ::= (SIZE_TYPE? (IDENTIFIER|LBL))
private NumericLiteral ::= ((PLUS|MINUS)? (BINARY|(HEXADECIMAL (COLON HEXADECIMAL)?)|DECIMAL|CHARACTER))
private ArithmeticOperation ::= (PLUS|MINUS|TIMES|DIVIDE)

